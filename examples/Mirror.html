<!DOCTYPE html>
<!-- saved from url=(0068)http://web.cs.iastate.edu/~smkautz/cs336f15/examples/fbo/Mirror.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Texture with lighting</title>
</head>

<body> 
	<canvas id="theCanvas" width="600" height="600">
    Please use a browser that supports "canvas"
    </canvas>

<p>
</p><li>SPACE - pause rotation
</li><li>x - rotate about x axis
</li><li>y - rotate about y axis
</li><li>z - rotate about z axis
<p>
Camera controls:
</p><ul style="list-style:none;">
<li>w, a, s, d - move forward, left, back, right
</li><li>r, f - move up, down
</li><li>i, j, k, l - look up, left, down, right
</li><li>I, J, K, L - orbit down, right, up, left
</li><li>O - face origin
</li><li>p - put camera at origin
</li><li>W - decrease fov
</li><li>S - increase fov
</li><li>1, 2, 3, 4, 5 - change texture parameters
</li></ul>


<script id="vertexLightingShader" type="x-shader/x-vertex">
precision mediump float;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform mat3 normalMatrix;
uniform vec4 lightPosition;

attribute vec4 a_Position;
attribute vec3 a_Normal;
attribute vec2 a_TexCoord;

varying vec3 fL;
varying vec3 fN;
varying vec3 fV;
varying vec2 fTexCoord;
void main() 
{
  // convert position to eye coords
  vec4 positionEye = view * model * a_Position;

  // convert light position to eye coords
  vec4 lightEye = view * lightPosition;

  // vector to light
  fL = (lightEye - positionEye).xyz;

  // transform normal matrix into eye coords
  fN = normalMatrix * a_Normal;

  // vector from vertex position toward view point
  fV = normalize(-(positionEye).xyz);

  fTexCoord = a_TexCoord;

  gl_Position = projection * view * model * a_Position;
}
</script>


<script id="fragmentLightingShader" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 materialProperties;
uniform mat3 lightProperties;
uniform float shininess;
uniform sampler2D sampler;

varying vec3 fL;
varying vec3 fN;
varying vec3 fV;
varying vec2 fTexCoord;

void main() 
{
  // normalize after interpolating
  vec3 N = normalize(fN);
  vec3 L = normalize(fL);
  vec3 V = normalize(fV);

  // reflected vector
  vec3 R = reflect(-L, N);

  // get the columns out of the light and material properties.  We keep the surface
  // properties separate, so we can mess with them using the sampled texture value
  vec4 ambientSurface = vec4(materialProperties[0], 1.0);
  vec4 diffuseSurface = vec4(materialProperties[1], 1.0);
  vec4 specularSurface = vec4(materialProperties[2], 1.0);

  vec4 ambientLight = vec4(lightProperties[0], 1.0);
  vec4 diffuseLight = vec4(lightProperties[1], 1.0);
  vec4 specularLight = vec4(lightProperties[2], 1.0);

  // sample from the texture at interpolated texture coordinate
  vec4 color = texture2D(sampler, fTexCoord);

  // (1) use the value directly as the surface color and ignore the material properties
  ambientSurface = color;
  diffuseSurface = color;

  // (2) modulate intensity of surface color (or of any component)
  //float m = (color.r + color.g + color.b) / 3.0;
  //ambientSurface *= m;
  //diffuseSurface *= m;
  //specularSurface *= m;

  // (3) blend texture using its alpha value (try this with "steve.png")
  //float m = color.a;
  //ambientSurface = (1.0 - m) * ambientSurface + m * color;
  //diffuseSurface = (1.0 - m) * diffuseSurface + m * color;
  //specularSurface = (1.0 - m) * specularSurface + m * color;

  // lighting factors as usual

  // Lambert's law, clamp negative values to zero
  float diffuseFactor = max(0.0, dot(L, N));

  // specular factor from Phong reflection model
  float specularFactor = pow(max(0.0, dot(V, R)), shininess);

  // add the components together, note that vec4 * vec4 is componentwise multiplication,
  // not a dot product
  vec4 ambient = ambientLight * ambientSurface;
  vec4 diffuse = diffuseFactor * diffuseLight * diffuseSurface;
  vec4 specular = specularFactor * specularLight * specularSurface;
  gl_FragColor = ambient + diffuse + specular;
  gl_FragColor.a = 1.0;
}
</script>

<script id="vertexTextureShader" type="x-shader/x-vertex">
uniform mat4 transform;
attribute vec4 a_Position;
attribute vec2 a_TexCoord;
varying vec2 fTexCoord;
void main() 
{
  // pass through so the value gets interpolated 
  fTexCoord = a_TexCoord;
  gl_Position = transform * a_Position;
}
</script>

<script id="fragmentTextureShader" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D sampler;
varying vec2 fTexCoord;
void main() 
{
  // sample from the texture at the interpolated texture coordinate,
  // use the texture's alpha to blend with given color
  vec4 texColor = texture2D(sampler, fTexCoord);
  gl_FragColor = texColor;
}
</script>



<script id="vertexColorShader" type="x-shader/x-vertex">
uniform mat4 transform;
attribute vec4 a_Position;
attribute vec4 a_Color;
varying vec4 color;
void main() 
{
  color = a_Color;
  gl_Position = transform * a_Position;
}
</script>

<script id="fragmentColorShader" type="x-shader/x-fragment">
precision mediump float;
varying vec4 color;
void main() 
{
  gl_FragColor = color;
}
</script>



		<script src="../../teal_book/webgl-utils.js"></script>
		<script src="../../teal_book/webgl-debug.js"></script>
		<script src="../../teal_book/cuon-utils.js"></script>
		<script src="../../teal_book/cuon-matrix.js"></script>
		<script src="./Camera.js"></script>
		
		<!-- Use three.js if you have it locally, for easier debugging -->
		<!--script src="../threejs/three.js"></script-->
		
		<!--  otherwise, load the minified version from the www -->
		<script src="../threejs/three.js"></script>
		
		<!-- the OBJ file loader is not included in the regular three.js file -->
		<script src="../threejs/OBJLoader.js"></script>
		
		<script src="Mirror.js"></script>
		<script>window.onload = main</script>

</li></body></html>